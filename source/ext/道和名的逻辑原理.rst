.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2022-09-30
:Status: Draft

道和名的逻辑原理
****************

“道”是我们觉得外部客观存在而引起我们感知的那个东西，名是我们对这些感知信息的总
结。用逻辑哲学论的观点来看，道的信息只能Pass over in silence，你说某个东西是青
蛙，认不认同，没有什么严格的证明的，只能是“你知我知”，交流永远都存在这样一部分
信息，只能“你知我知”，没有办法严格谈逻辑的。等我们有共识了，那就是可以严格讨论
的“名”，我们都说这是“青蛙”，都承认“青蛙有四条腿”，那我们就可以有推理出来“这两只
青蛙有一样的腿的数目”。后面这些讨论就是可以严格的，是Tractatus，是逻辑statement
中的主语（Object）和谓词(Predicate）。

用逻辑来理解名，名其实很简单，名是集合，只有在集合中，和不在集合中两个属性。我
是我，不是你，不是他，我就是一个集合。只有是，否和“不知”三个认识。当然，谓词逻
辑还有关联的概念（比如青蛙和四条腿两个概念就有关联），但如果只是泛泛来认识，我
们一定程度上可以认为关联也是某种程度的集合而已。

名本身也是道。你说：“不要吵”，这是句话本身是名，但这句话的发生是道。所以，我说
“你禁止了其他人的发出声音”，这是对你说“不要吵”这件事的一个总结。所以，名是有层
次的。对另一组名的总结，构建了一组名。在这个上下文中，后者是前者的名，前者是后
者的道。这是造成各种混乱的重要原因。作为一个软件架构师，我经常会遇到这样的问题：
比如我把系统分解了五个模块，定义了五个模块之间的关系，然后我让工程师A去做模块1
的设计。

注意这个表述了：我让工程是A去——“做模块1的设计”。

“做模块1的设计”是一个总结，是一个名。而工程师A要变成道，就得去做这件事本身，但
如果工程师A写的设计是：“我们要做一个模块1的设计”。那他就完全没有做这个设计了。
但他是不是在做“模块1的设计”呢？你很难说他不是，因为他确实说“做模块1的设计”。

说到底，名是道的抽象。道包含更多的信息，而名表示了更大的范围。道是常量，所有东
西都是确定的。而名包含变量，我们只是指定了一个集合，所有符合集合的内容都是名的
范围内的。“做模块A的设计”，可以表现为写下一段程序，也可以表现为写出一个流程图。
“做模块A的设计”这个描述包括了所有这些变数，而写下一段程序和写下一个流程图是“做
模块A中的一个具像”。在名和道这个层级关系中，高一级的名，比更接近道的那个名表示
的集合范围更大。

因为名是集合，所以名本身包含了目标。从中可以暴露名的创造者的目标。道之为物，唯
恍唯惚。为什么会恍惚，因为你实际感知的任何东西，在没有确定目标前，是没有意义的。
就算这个信息并不复杂。比如说，儿子回来告诉你，这次考试考了80分。你是什么感觉？
80分在你的目标中不构成一个集合，不能用来做判断，这个80分，就是一个恍惚。

什么时候它不是恍惚呢？当你作出这样判断的时候，它就不恍惚了：

1. 总分100分，这个成绩算中上。
2. 全班最高分100，最低分75，这个成绩在班不行。
3. 全班中位数90分，也不差，这还是比不过同学。
4. 隔壁王大妈的儿子才77，比咱家孩子差。
5. ……

加上这个目标，这个成绩就不恍惚了。名字的确定性，都是来自这种只有是和否的比较，
才会变成逻辑上有效的信息。即使仅仅是一个简单的数字。所以，我们获取信息的时候，
是通过设计很多的目标来比较这个信息，没有这样的目标，只是漫无目地把信息原封不动
地接纳进来，这个信息是传递不进来的。
